<!DOCTYPE HTML>
<html lang="chinese">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="poly000,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Galileo" />
    <link rel="alternate" type="application/rss+xml" title="poly000客栈 &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="poly000客栈 &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="/assets/galileo-8d8763e752.css">
    <link rel="stylesheet" href="/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="/assets/katex.min.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700&display=swap">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "/86ca49a4b1751ab2cb30eaeb0d09ab3d.json"
        }
    </script>
    
<title>一些不错的Rust不稳定特性 - poly000客栈</title>
<meta name="author" content="Poly000" />
<meta name="description" content="关于翻译" />
<meta property="og:title" content="一些不错的Rust不稳定特性 - poly000客栈" />
<meta property="og:description" content="关于翻译" />
<meta property="og:site_name" content="poly000客栈" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/awesome-unstable-rust-features/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2021-07-28T15:04:00+08.00" />
<meta name="twitter:title" content="一些不错的Rust不稳定特性 - poly000客栈" />
<meta name="twitter:description" content="关于翻译" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
    </head>
    
    <body>
        
        <div class="container">
            <header id="ga-header">
                <div first>
                    <aside id="ga-brand">
                        <h1 class="brand"><a class="no-style" href="/">poly000客栈</a></h1>
                        <p>poly000 的碎碎念</p>
                    </aside>
                </div>
                <div second id="ga-nav">
                    <nav class="navs">
                        <ul><li><a class="ga-highlight" href="/" target="_self">Home</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/archives/" target="_self">Archives</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/about/" target="_self">About</a></li><span class="separator">·</span><li><a href="#" target="_self" class="search-form-input ga-highlight">Search</a></li></ul>
                    </nav>
                </div>
            </header>
            <div class="wrapper">
                
<main>    
    <section class="ga-section ga-content">
        <article class="yue">
            <h1 class="ga-post_title">一些不错的Rust不稳定特性</h1>
            <span class="ga-post_meta ga-mono">
                <span>Poly000</span>
                <time>
                    2021-07-28
                </time>
                
                in <a no-style class="category" href="/category/Programming/">
                    Programming
                </a>
                
                
                <span class="leancloud_visitors" 
                    id="/archives/awesome-unstable-rust-features/" 
                    data-flag-title="一些不错的Rust不稳定特性"> · <i class="leancloud-visitors-count"></i> Views</span>
                
            </span>
            <div class="ga-content_body">
                <h2>关于翻译</h2>
<p>主要译者：<a href="https://github.com/poly000">poly000</a></p><p>参考了这些人（排名不分先后）的建议：<a href="https://github.com/unsafeIO">unsafeIO</a>，<a href="https://github.com/xieyuheng">xieyuheng</a>，<a href="https://github.com/oxalica">oxa</a>。</p><p>术语部分翻译参考了 <a href="https://rustwiki.org/wiki/translate/english-chinese-glossary-of-rust/">Rust 语言术语中英文对照表</a>，有改动。</p><p>如果有翻译错误，请您<a href="https://github.com/poly000/poly000.github.io/issue">在仓库中指出</a>！</p><p>如果有原文错误，请联系 <a href="https://twitter.com/efun_b">Ethan Brierley</a> 且联系我更新翻译。</p><p>汉化进度： 361/846 行</p><h2>Credits</h2>
<p><a href="https://lazy.codes/posts/awesome-unstable-rust-features/">原文</a> by <a href="https://twitter.com/efun_b">Ethan Brierley</a></p><h2>简介</h2>
<p>这篇文章介绍了一些尚不稳定的 Rust 编译器特性。它将会简要叙述这些特性，并不会深入太多的细节。</p><h2>什么是不稳定 Rust？</h2>
<p>Rust 发布于三个渠道： stable，beta，以及 nightly。</p><p>Nightly 编译器每天都会发布，而且唯有它允许你解锁不稳定 Rust 特性。</p><blockquote>
<p>这篇文章只讨论不稳定编译器特性，不稳定的库特性不属于这个话题。</p></blockquote>
<h2>为什么要用不稳定特性？</h2>
<p>不稳定 Rust 可以让你使用在稳定 Rust 中无法表示的API。正因如此，编译器与标准库都使用了不稳定特性。</p><p>使用不稳定的特性总是伴随着一些风险。它们经常会有一些意想不到的行为，有时甚至会破坏 Rust 的内存安全保证，导致未定义行为。一部分特性可能开发的很好，而另一部分可能未被开发。</p><p>对于使用不稳定特性的 Nightly 编译器，遇到“内部编译器错误”并不少见，这种情况通常称为<a href="https://github.com/rust-lang/rust/labels/I-ICE">ICE</a>。它发生于编译过程中，编译器将会恐慌。这可能是由于数据与查询操作因未完成的特性而畸形，甚至可能只是因为未做出的特性部分被打了一个 <code>todo!()</code>。</p><p>如果你遇到了ICE，检查一下这个问题是否已知，否则就把它报告给<a href="https://github.com/rust-lang/rust/issues">bug tracker</a>。</p><p>Rust 不保证在未来继续支持它的不稳定特性。
作为 Rust 开发者，我们享受着优秀的向下兼容性与稳定性，
而启用不稳定特性时，这些保证都被抛在脑后。
今天工作的程序可能明天就大不相同。</p><p>我决定研究不稳定特性，不是因为我需要用它们去解决实际问题。
我寻找它们是因为我觉得他们很有趣。
对我来说，使用不稳定的特性，是一种有趣的，使我更多地参与到语言本身的开发过程的方法。</p><blockquote>
<p>不稳定特性的全面列表见<a href="https://github.com/rust-lang/rust/blob/135ccbaca86ed4b9c0efaf0cd31442eae57ffad7/src/librustc_feature/active.rs#L83-L530">不稳定特性列表</a>。</p></blockquote>
<h2>启用不稳定特性</h2>
<p>为了开始使用不稳定特性，首先你需要安装 Nightly 工具链：</p><div class="highlight"><pre><span></span>rustup toolchain install nightly
</pre></div>
<p>若要使用 Nightly 工具链，你需要在运行命令时加上 <code>+nightly</code> 修饰符。</p><div class="highlight"><pre><span></span>&lt;rust-command&gt; +nightly &lt;args&gt;
</pre></div>
<p>For example:</p><div class="highlight"><pre><span></span>cargo +nightly run
</pre></div>
<p>另外，你可以将你的默认编译器改为 Nightly ，这样你就不再需要使用 <code>+nightly</code> 修饰符。
我经常这样做，因为我不认为 nightly 编译器很不稳定，即使对于我的在 stable 上可以编译的项目也是这样。</p><div class="highlight"><pre><span></span>rustup default nightly
</pre></div>
<p>一旦你使用 nightly 编译器，你就可以直接开始使用不稳定特性。让我们试一试吧！</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>它会导致这样的编译错误：</p><div class="highlight"><pre><span></span><span class="n">error</span><span class="p">[</span><span class="n">E0658</span><span class="p">]</span>: <span class="nc">box</span><span class="w"> </span><span class="n">expression</span><span class="w"> </span><span class="n">syntax</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">experimental</span><span class="p">;</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="err">`</span><span class="nb">Box</span>::<span class="n">new</span><span class="err">`</span><span class="w"> </span><span class="n">instead</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">2</span>:<span class="mi">18</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"></span>
<span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="n">my_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="o">^^^^^</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"></span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">see</span><span class="w"> </span><span class="n">issue</span><span class="w"> </span>#<span class="mi">49733</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//github.com/rust-lang/rust/issues/49733&gt; for more information</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">add</span><span class="w"> </span><span class="err">`</span><span class="cp">#![feature(box_syntax)]</span><span class="err">`</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">enable</span><span class="w"></span>
</pre></div>
<p>正如以往，Rust 在 <code>help</code> 消息中准确地告诉了我们需要做什么。
我们需要用 <code>#![feature(box_syntax)]</code> 启用这个特性。</p><div class="highlight"><pre><span></span><span class="cp">#![feature(box_syntax)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>所有不稳定特性都需要在可以使用前以 <code>#![feature(..)]</code> 启用。
如果你忘记了，编译器<strong>通常</strong>会正确地指出要如何做，然而，并非总会这样。</p><p>现在，让我们开始讨论一些特性本身。
我把你需要启用的特性名称放在每个特性的标题中的 <code>代码块</code> 中，而在代码片段中省略它们，以保持简洁。</p><h2>控制流、模式和块</h2>
<h3><code>destructuring_assignment</code></h3>
<p>在Rust中，在绑定某一类型到一个定义时解构它是很常见的。
这通常是通过 <code>let</code> 绑定完成的。</p><div class="highlight"><pre><span></span><span class="c1">// 创建两个 &quot;变量&quot;, 一个是 x, 一个是 y </span>
<span class="kd">let</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">random</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>传统上，这种模式只有在实例化一个新定义时才能实现。
<code>destructuring_assignment</code> 将它拓展到可用于修改值时。</p><!-- extends this to work when mutating values -->
<p>换句话说，我们可以不使用 <code>let</code> 完成解构。</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">random</span><span class="p">();</span><span class="w"></span>
</pre></div>
<h3>从任意块提前返回，<code>label_break_value</code></h3>
<p>一个很少被知道的 Rust 特性是，<a href="https://doc.rust-lang.org/edition-guide/rust-2018/control-flow/loops-can-break-with-a-value.html"><code>loop</code>可以带值退出</a>。
就像 Rust 中许多其它的结构，在 Rust 中 <code>loop</code> 并不仅仅是语句, 而是<a href="https://doc.rust-lang.org/reference/statements-and-expressions.html">表达式</a>。</p><div class="highlight"><pre><span></span><span class="c1">// 保持请求用户输入一个数字，直到他们给出一个有效的数字。</span>
<span class="kd">let</span><span class="w"> </span><span class="n">number</span>: <span class="kt">u8</span> <span class="o">=</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">().</span><span class="n">parse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Invaid number, Please input a valid number&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p><code>label_break_value</code> 把它拓展到可用于任何被标记的块，而不仅仅是 <code>loop</code>。
它的行为，就像是一种提前的 <code>return</code> ，不过适用于任何代码块，而不只是函数体。</p><p>标记代码块的语法，和生命周期很相似。</p><div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="na">block</span>: <span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="c1">// 这个代码块现在被标记为 &quot;block&quot; 。</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>现在也可以用同样的方式<a href="https://doc.rust-lang.org/rust-by-example/flow_control/loop/nested.html">标记<code>loop</code></a>。</p><p>我们可以把标签放在 <code>break</code> 后面，从那个代码块提前返回。</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&#39;</span><span class="na">block</span>: <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;block</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 从代码块提前返回</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<blockquote>
<p>这个特性<a href="http://david.tribble.com/text/goto.html">不等价于goto</a>。
它没有 goto 那样的破坏性影响，他只是往后继续执行，从一个代码块中退出。</p></blockquote>
<h3>使用 <code>try_blocks</code> 内联 <code>?</code> 操作符的功能</h3>
<p><a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">版本引导</a>使用这个例子展示问号运算符是如何工作的：</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&quot;username.txt&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>使用 <code>?</code> 操作符简化代码，可以得到这样等效的代码：</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&quot;username.txt&quot;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><code>?</code> 在函数中被用于遇到 <code>Err</code> 时提前返回它。
<code>try_blocks</code> 解锁了适用于任意代码块而不仅仅是函数的相同功能。
使用 <code>try_blocks</code> 我们可以内联我们的 <code>read_usernames_from_file</code> 函数。</p><p><code>try_blocks</code> 和 <code>?</code> 的关系就像是 <code>label_break_value</code> 和 <code>return</code> 的关系。
<code>try_blocks</code> 的RFC提到了 <code>label_break_value</code> ，作为一种可能的 <code>try_blocks</code> 解读方式。</p><p>接写来重写我们的 <code>read_username_from_file</code> 成一个简单的 <code>let</code> 绑定与一个 <code>try</code> 代码块。</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">read_username_from_file</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&quot;username.txt&quot;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>我喜欢这种东西。特别是较小的表达式，如果不提取成函数，易读性会更好。</p><h3><code>inline_const</code></h3>
<p>目前，获取一个编译时计算的值需要定义一个常量。</p><blockquote>
<p>译者注：或者是 <code>const fn</code></p></blockquote>
<div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">PI_APPROX</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">22.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">7.0</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">PI_APPROX</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>使用 <code>inline_const</code> 我们可以用匿名表达式完成同样的事。</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">22.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">7.0</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>在这个简单的例子中， <code>const</code> 块几乎完全是不必要的，因为编译器的优化<a href="https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html">constant propagation</a>。
然而，对于更复杂的常量，用块来表示可能很有益。</p><p>这个特性也允许这些块在模式中使用。
<code>match x { 1 + 3 =&gt; {} }</code> 会导致格式错误，而 <code>match x { const { 1 + 3 } =&gt; {} }</code> 不会。</p><h3><code>if_let_guard</code></h3>
<p>拓展可用在 <code>match</code> 表达式中的 <a href="https://doc.rust-lang.org/beta/rust-by-example/flow_control/match/guard.html"><code>if</code> 守卫</a> ，允许使用 <code>if let</code>。</p><blockquote>
<p>译注：原文中使用了 &quot;<code>match</code> statement&quot; 的说法，这里翻译为 <code>match</code> 表达式。</p></blockquote>
<h3><code>let_chains</code></h3>
<p>目前，<code>if let</code> 和 <code>while let</code> 表达式不能以 <code>||</code> 或 <code>&amp;&amp;</code> 连接，
这个特性添加了支持。</p><h2>Traits</h2>
<h3><code>associated_type_bounds</code></h3>
<p>看看这个稳定 Rust 函数：</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">fizzbuzz</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">val</span><span class="o">|</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;FizzBuzz&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Fizz&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Buzz&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>通过 <code>associated_type_bounds</code> 特性，我们可以在这种情况下使用一个匿名类型。</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">fizzbuzz</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span>: <span class="nc">Display</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>看看这个吓人地冗长的类型签名：</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">flatten_twice</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Flatten</span><span class="o">&lt;</span><span class="n">Flatten</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nb">Iterator</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span>::<span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="n">T</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">iter</span><span class="p">.</span><span class="n">flatten</span><span class="p">().</span><span class="n">flatten</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>使用这个特性，我们可以简单地写成：</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">flatten_twice</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Flatten</span><span class="o">&lt;</span><span class="n">Flatten</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">iter</span><span class="p">.</span><span class="n">flatten</span><span class="p">().</span><span class="n">flatten</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Which is far easier for me to reason about.</p><h3><code>default_type_parameter_fallback</code>, <code>associated_type_defaults</code> and <code>const_generics_defaults</code></h3>
<p>These features allow you to specify default values for <a href="https://github.com/rust-lang/rfcs/blob/master/text/0213-defaulted-type-params.md">generic types</a>, <a href="https://github.com/rust-lang/rfcs/blob/master/text/2532-associated-type-defaults.md">associated types</a> and <a href="#const-generics">const variables</a> respectively in more places.</p><p>This allows you as a developer to create nicer APIs.
If a crate user is not interested in a detail and that item has a default then the detail can be omitted.
This also makes it easier to extend APIs without making breaking changes for your users.</p><h3><code>negative_impls</code> and <code>auto_traits</code></h3>
<p>Both of these features are used in the standard library. The traits <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> are both examples of auto traits.</p><p>The trait <code>Send</code> is <a href="https://doc.rust-lang.org/src/core/marker.rs.html#38-40">defined in the standard library as so</a>:</p><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// empty.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note the use of the <code>auto</code> keyword.
This tells the compiler to automatically implement the <code>Send</code> trait for any struct/enum/union as long as all the types that make up said type also implement <code>Send</code>.</p><p>Auto traits would not be very useful if simply every type always implemented them.
That is where <code>negative_impls</code> come in.</p><p><code>negative_impls</code> allows for a type to opt-out from implementing an auto trait.
Take for example <code>UnsafeCell</code>. It would be very unsafe for an unrestricted <code>UnsafeCell</code> to be shared across threads, therefore it would be very unsafe for it to be <code>Sync</code>.</p><div class="highlight"><pre><span></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="o">!</span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
<p>Note the creative use of <code>!</code> to express &quot;not <code>Sync</code>&quot;.</p><h3><code>marker_trait_attr</code></h3>
<p>This feature adds the <code>#[marker]</code> attribute for traits.</p><p>Rust disallows the defining of traits implementations that could overlap.
This is so that the compiler will always know which implementation to use because there will always be only one.</p><p>Traits marked with <code>#[marker]</code> cannot override anything in their implementations.
That way they are allowed to have overlapping implementations because all implementations will be the same.</p><h3><code>type_alias_impl_trait</code>, <code>impl_trait_in_bindings</code> and <code>trait_alias</code></h3>
<p><code>impl Trait</code> tells the compiler to infer a concrete type to replace it with that implements <code>Trait</code>.
Currently, <code>impl Trait</code> is only used in the context of function arguments or return types.</p><p><code>type_alias_impl_trait</code> and <code>impl_trait_in_bindings</code> extend the places <code>impl trait</code> can be used to include type aliases and <code>let</code> bindings respectively.</p><p><code>trait_alias</code> is subtlely different to <code>type_alias_impl_trait</code>.
Everywhere you use a type alias the type must remain constant.
A single concrete type must be inferred by the compiler that works in all those places.
Trait aliases are more forgiving as they can be a different type in each place they are used.</p><h3><code>fn_traits</code> and <code>unboxed_closures</code></h3>
<p>The three traits <code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code> are known as the fn traits.
They are automatically implemented for any functions or closures that you create and are what provides the ability to pass arguments to them.</p><p>An automatic implementation is currently the only way to implement those traits.
The <code>fn_traits</code> feature allows for custom implementations on any type.
This is very similar to operator overloading but customising the use of <code>()</code>.</p><div class="highlight"><pre><span></span><span class="cp">#![feature(unboxed_closures)]</span><span class="w"> </span><span class="c1">// required to implement a function with `extern &quot;rust-call&quot;`</span>
<span class="cp">#![feature(fn_traits)]</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Multiply</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[allow(non_upper_case_globals)]</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">multiply</span>: <span class="nc">Multiply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Multiply</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Multiply</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Multiply</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="mi">2</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Multiply</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>: <span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="mf">0.</span><span class="n">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="s">&quot;hello &quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;hello hello hello &quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Notice that this is being used to create a hacky version of <a href="https://en.wikipedia.org/wiki/Function_overloading">function overloading</a> and <a href="https://en.wikipedia.org/wiki/Variadic_function">variadic functions</a>.</p><h2>Sugar</h2>
<h3><code>box_patterns</code> and <code>box_syntax</code></h3>
<p>These two features make constructing and destructing <code>Box</code>es easier.
The <code>box</code> keyword replaces <code>Box::new(..)</code> and allows for the dereferencing <code>Box</code>es when pattern matching.</p><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">TrashStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span>: <span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">body</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">TrashStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TrashStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">elem</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">head</span>: <span class="nc">elem</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">body</span>: <span class="nb">Some</span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="bp">self</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">TrashStack</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">body</span>: <span class="nb">Some</span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="n">TrashStack</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}),</span><span class="w"></span>
<span class="w">            </span><span class="o">..</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This makes things a little more ergonomic but I don't think there is much chance that this feature will ever be stabilised.
It seems to have existed forever with no plan for stabilisation but instead a little discussion about removing the feature.
<code>box_synatx</code> is used heavily in the compiler's source and a little in the standard library.</p><p>It is interesting to note that <code>box</code> does not desugar to <code>Box::new</code> but <code>Box::new</code> is implemented in the standard library with <code>box</code>.</p><div class="highlight"><pre><span></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">box</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><code>async_closure</code></h3>
<p>Currently to be async inside of a closure you have to use an async block.</p><div class="highlight"><pre><span></span><span class="n">app</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
</pre></div>
<p><code>async_closure</code> allows you to mark the closure itself as async just like you would a async function.</p><div class="highlight"><pre><span></span><span class="n">app</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="k">async</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">));</span><span class="w"></span>
</pre></div>
<h3><code>in_band_lifetimes</code></h3>
<p>To use a lifetime it must be explicitly brought into scope.</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">select</span><span class="o">&lt;&#39;</span><span class="na">data</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span> <span class="nc">Data</span><span class="p">,</span><span class="w"> </span><span class="n">params</span>: <span class="kp">&amp;</span><span class="nc">Params</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span> <span class="nc">Item</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>With <code>in_band_lifetimes</code> the lifetimes can be used without bringing them into scope first.</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">select</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span> <span class="nc">Data</span><span class="p">,</span><span class="w"> </span><span class="n">params</span>: <span class="kp">&amp;</span><span class="nc">Params</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span> <span class="nc">Item</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Interestingly enough this was <a href="https://github.com/rust-lang/rfcs/pull/2115#issuecomment-323221054">how lifetimes used to work</a> pre <code>1.0.0</code>.</p><h3><code>format_args_capture</code></h3>
<p>This allows for named arguments to be placed inside of strings inside any macro that depends on <code>std::format_args!</code>.
That includes <code>print!</code>, <code>format!</code>, <code>write!</code> and many more.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Ferris&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Hello {name}, you are {age} years old&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>It is likely that this will be stabilised with or soon after edition 2021.</p><h3><code>crate_visibility_modifier</code></h3>
<p>With this feature you can write <code>crate struct Foo</code> rather than <code>pub(crate) struct Foo</code> and have it mean exactly the same thing.</p><p>This makes <code>pub(crate)</code> easier to write, encouraging the use of crate visibility when full <code>pub</code> is not necessary.</p><h2>Types</h2>
<h3><code>type_ascription</code></h3>
<p>Take for example the <code>collect</code> method on <code>Iterator</code>.
Collect transforms an interator into a collection.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>This does not compile because Rust is unable to infer the type of <code>word</code>.
This can be fixed by replacing the first line with:</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">word</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>With <code>type_ascription</code> the <code>let</code> binding is no longer necessary and one can simply:</p><div class="highlight"><pre><span></span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The <code>: Type</code> syntax can be used anywhere to hint at the compiler &quot;I want this type at this point&quot;.</p><h3><code>never_type</code></h3>
<p>It is possible to define <code>enum</code>s with zero variants.
Such an enum exists stable in the standard library.</p><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Infallible</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
<p>It is possible to use this type in generics and function signatures but never possible for it to be constructed.
There are simply no variants to construct.</p><p>The unit type, <code>()</code> would be equivalent to an enum with a single variant.
<code>never_type</code> introduces a new type, <code>!</code> which is equivalent to our <code>Infallible</code> enum with zero variants.</p><p>Because <code>!</code> can never be constructed it can be given special powers.
We don't have to handle the case of <code>!</code> because we have proven it will never exist.</p><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Loops without a <code>break</code> &quot;return <code>!</code>&quot; because they don't ever return.</p><p><code>!</code> can be very useful for expressing impossible outcomes in the type system.
Take for example the <code>FromStr</code> implementation on this <code>UserName</code> type.
This implementation is infallible because its implementation can never fail.
This allows us to set the <code>Err</code> variant to type <code>!</code>.</p><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">UserName</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UserName</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">Self</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">to_owned</span><span class="p">()))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It is then possible to use an empty <code>match</code> on the <code>Err</code> variant because <code>!</code> has no variants.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">UserName</span>::<span class="n">from_str</span><span class="p">(</span><span class="s">&quot;ethan&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">{},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>With the feature <code>exhaustive_patterns</code> the type system becomes smart enough for us to eliminate the <code>Err</code> branch altogether.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">UserName</span>::<span class="n">from_str</span><span class="p">(</span><span class="s">&quot;ethan&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>We can combine this with destructuring to remove the <code>match</code> leaving a beautiful line of code.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">user_name</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UserName</span>::<span class="n">from_str</span><span class="p">(</span><span class="s">&quot;ethan&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h2>Attributes</h2>
<h3><code>optimize_attribute</code></h3>
<p>It is possible to specify how you want your binary to be optimised with <code>Cargo.toml</code> <a href="https://doc.rust-lang.org/book/ch14-01-release-profiles.html">using <code>opt-level</code></a>.</p><p>The <code>opt-level</code> affects the entire crate while the <code>optimize_attribute</code> can control optimization for individual items.</p><div class="highlight"><pre><span></span><span class="cp">#[optimize(speed)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">fast_but_large</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#[optimize(size)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">slow_but_small</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This would be very useful for fine-tuning applications where the trade off between size and performance is particularly pronounced such as when using <a href="https://webassembly.org/">web assembly</a>.</p><h3><code>stmt_expr_attributes</code></h3>
<p>This feature allows you to place attributes almost everywhere not just top-level items. For example with this feature, you are able to place an <a href="#optimize-attribute">optimize attribute</a> on a closure.</p><h3><code>cfg_version</code></h3>
<p>This feature allows for conditional compilation based on compiler version.</p><div class="highlight"><pre><span></span><span class="cp">#[cfg(version(</span><span class="s">&quot;1.42&quot;</span><span class="cp">))]</span><span class="w"> </span><span class="c1">// 1.42 and above</span>
<span class="k">fn</span> <span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(not(version(</span><span class="s">&quot;1.42&quot;</span><span class="cp">)))]</span><span class="w"> </span><span class="c1">// 1.41 and below</span>
<span class="k">fn</span> <span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This allows crates to make use of the latest compiler features while still keeping fallback support for old compilers.</p><h3><code>no_core</code></h3>
<p>It has been possible to opt-out of using the standard library using <code>#![no_std]</code> for a while.
This is important for applications that don't run in a full environment such as embedded systems.
Embedded systems often don't have an operating system or even dynamic memory so many of the functions in <code>std</code> wouldn't work.</p><p><code>#![no_core]</code> takes it further by opting out of libcore.
That leaves you with almost nothing, you can't even use libc.
This makes it very difficult to implement anything useful.</p><h2>Other</h2>
<h3>Const Generics</h3>
<p>I spoke about the future of const_generics <a href="/posts/intro-to-const-generics/">at my talk for Rust Dublin</a>.
Rather than me reiterating what I said there, I encourage you to <a href="/posts/intro-to-const-generics/">watch that talk</a>.</p><h2>Macros 2.0</h2>
<p>Rust's declarative macros are very powerful however some of the rules around <code>macro_rules!</code> have always confused me.</p><p>For one, <code>macro_rules!</code> acts as a simple token transformation.
It takes a list of tokens and outputs a new list of tokens, nothing smarter than that.
The publicity rules end up being the rules of where the macro is being called.
This is obvious because the codes is being simply pasted into that place.</p><p>Macros 2.0 is an rfc describing a replacement to <code>macro_rules!</code> with a new construct simply using the keyword <code>macro</code>.</p><p>One of the main improvements the new syntax introduces is macro hygiene which allows macros to use the publicity rules of where they are written rather than where they are called.</p><h3><code>generators</code></h3>
<p>Generators/coroutines provide a special kind of function that can be paused during execution to &quot;yield&quot; intermediate values to the caller.</p><p>Generators can return multiple values using the <code>yield</code> keyword, each time pausing the function and returning to the caller.
A generator can then <code>return</code> a single value after which it can no longer be resumed.</p><p>About three years ago I attempted to write an algorithm to traverse an infinite matrix along its diagonals.
I found it very difficult to write that with Rust's iterators and ended up giving up.</p><p>Here is an implementation using Rust's generators/coroutines along with a number of other features we've discussed already.</p><div class="highlight"><pre><span></span><span class="cp">#![feature(</span>
<span class="cp">    try_blocks,</span>
<span class="cp">    generators,</span>
<span class="cp">    generator_trait,</span>
<span class="cp">    associated_type_bounds,</span>
<span class="cp">    type_ascription</span>
<span class="cp">)]</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">iter</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ops</span>::<span class="p">{</span><span class="n">Generator</span><span class="p">,</span><span class="w"> </span><span class="n">GeneratorState</span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="n">pin</span>::<span class="n">Pin</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="sd">/// Input</span>
<span class="sd">/// [[1, 2, 3]</span>
<span class="sd">/// ,[4, 5, 6]</span>
<span class="sd">/// ,[7, 8, 9]]</span>
<span class="sd">/// Output</span>
<span class="sd">/// [1, 2, 4, 3, 5, 7]</span>
<span class="k">fn</span> <span class="nf">diagonalize</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">matrix</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kr">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">rows</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="o">?</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">height</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">rows</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">rows</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="o">?</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="kr">yield</span><span class="w"> </span><span class="n">rows</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">next</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">iter</span>::<span class="n">once</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">cycle</span><span class="p">().</span><span class="n">enumerate</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">diagonals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diagonalize</span><span class="p">(</span><span class="n">matrix</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">GeneratorState</span>::<span class="n">Yielded</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">diagonals</span><span class="p">).</span><span class="n">resume</span><span class="p">(())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<blockquote>
<p>It is understandable if you found the above snippet hard to interpret.
It makes use of a number of features that you may have just been introduced to.</p><p>There is a compelling argument against adding too many new features as they can greatly increase the learning curve.</p></blockquote>
<p>Generators make it possible to write implementations that are far more difficult or even impossible to write without them.</p><p>Generators were added to implement async-await in the standard library.
It is most likely that the exact semantics will change before any kind of stabilisation but they are very fun to play with.</p><h3>Final thoughts</h3>
<p>I have to apologise for not including three amazing unstable features; <a href="https://github.com/rust-lang/rfcs/blob/master/text/1598-generic_associated_types.md">Generic associated types</a>, <a href="https://rust-lang.github.io/rfcs/2873-inline-asm.html">inline asm</a> and <a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialization</a>.
I simply did not feel able to give these features justice in this article but I may try to talk about them in future.</p><p>If you wish to read more about an unstable feature the best place to start is <a href="https://doc.rust-lang.org/beta/unstable-book/the-unstable-book.html">the unstable book</a> where most of them are listed.
The unstable book then links to a <a href="https://github.com/rust-lang/rust/labels/C-tracking-issue">tracking issue</a> which then often, in turn, links to an <a href="https://rust-lang.github.io/rfcs/">RFC</a>.
With this combination of sources, you can then build up a picture of the details surrounding a feature.</p><p>Thank you for reading my first blog post 😃.
The best way to support me is by following my <a href="https://twitter.com/efun_b">Twitter</a>.
I am also looking for employment opportunities so please get in touch if you would like to talk about that.</p>
            </div>
        </article>
        <div id="ga-tags">
    
    <span class="ga-tag">
        <a class="ga-highlight" href="/tag/Rust/">#Rust</a>
    </span>
    
    <span class="ga-tag">
        <a class="ga-highlight" href="/tag/Language_feature/">#Language_feature</a>
    </span>
    
</div>
    </section>

    
<section id="ga-content_pager">

    <div class="next">
        <h3>No More</h3>
        <p class="yue">This is the latest one.</p>
    </div>


    <div class="prev">
        <a class="ga-highlight" href="/archives/enable-osdlyrics-netease-translation/">关于 Osdlyrics 网易来源启用翻译</a>
        <p class="yue">引言</p>
    </div>

</section>


    
        <script>
            var initValine = function () {
                new Valine({"enable": true, "el": "#vcomments", "appId": "IKRAfuPq0zrz6Wfje8ahHAIP-gzGzoHsz", "appKey": "lFaCWkd4xCs0Ng5UWs1eHNwU", "visitor": true, "recordIP": true});
            }
        </script>
        <script defer src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        <div id="vcomments"></div>
    

</main>

                <footer class="ga-mono" id="ga-footer">
                    <section>
                        <span id="ga-uptime"></span>
                        <span class="brand">poly000客栈</span>
                    </section>
                    <section>
                        <p class="copyright">
                            <span>Copyright © 2021 poly000</span>
                            <span>Powered by <a no-style href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Galileo</a></span>
                        </p>
                        <div class="copyright">
                            <span class="footer-addon">
                                
                            </span>
                            <nav class="social-links">
                                <ul><li><a class="no-style" title="GitHub" href="https://github.com/poly000" target="_blank"><i class="gi gi-github"></i>GitHub</a></li><span class="separator">·</span><li><a class="no-style" title="Bilibili" href="https://liolok.com/" target="_blank"><i class="gi gi-bilibili"></i>Bilibili</a></li></ul>
                            </nav>
                        </div>
                    </section>
                    <script>
                        var site_build_date = "2020-09-29:00+08:00"
                    </script>
                    <script src="/assets/galileo-7c8cea54ab.js"></script>
                </footer>
            </div>
        </div>
    </div>

    <!--katex-->
    <script defer src="/assets/katex.min.js"></script>
    <script>
    mathOpts = {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\[", right: "\\]", display: true},
            {left: "$", right: "$", display: false},
            {left: "\\(", right: "\\)", display: false}
        ]
    };
    </script>
    <script defer src="/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    <script src="/assets/ExSearch/jquery.min.js"></script>
    <script src="/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    
    </body>
</html>