<!DOCTYPE HTML>
<html lang="chinese">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="poly000,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Kepler" />
    <link rel="alternate" type="application/rss+xml" title="poly000客栈 &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="poly000客栈 &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="/assets/kepler-426969802d.css">
    <link rel="stylesheet" href="/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "/1ab23c650094fed7eecbb9cca810b2be.json"
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function(){
            if(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)){
                document.body.classList.add('safari')
            }else{
                document.body.classList.remove('safari')
            }
        });
    </script>
    
<title>一些不错的Rust Unstable特性 - poly000客栈</title>
<meta name="author" content="Poly000" />
<meta name="description" content="注意" />
<meta property="og:title" content="一些不错的Rust Unstable特性 - poly000客栈" />
<meta property="og:description" content="注意" />
<meta property="og:site_name" content="poly000客栈" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/awesome-unstable-rust-features/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2021-07-28T15:04:00+08.00" />
<meta name="twitter:title" content="一些不错的Rust Unstable特性 - poly000客栈" />
<meta name="twitter:description" content="注意" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
    </head>
    
    <body class="content">
        <header>
            <div class="container">
                <section>
                    <a href="/"><img src="/android-chrome-512x512.png">poly000客栈</a>
                </section>
                <section>
                    <nav>
                        <ul>
                            
                                <li><a href="https://liolok.com/" target="_blank">liolok</a></li>
                            
                                <li><a href="https://blog.i7.homes/" target="_blank">Integral</a></li>
                            
                                <li><a href="http://leoncha.online/" target="_blank">Leon Cha</a></li>
                            
                                <li><a href="https://www.aidenpers.xyz" target="_blank">aidenpers</a></li>
                            
                                <li><a href="https://controlnet.space/" target="_blank">ControlNet</a></li>
                            
                                <li><a href="https://sbchild.top/blog/" target="_blank">Sbchild</a></li>
                            
                                <li><a href="https://blog.bluempty.com/" target="_blank">HypengW</a></li>
                            
                        </ul>
                    </nav>
                </section>
    
                <section>
                    <a hidden class="toggle-toc" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('toc-open')"><i class="fa fa-align-right"></i></a>
                    <a hidden class="toggle-navbar" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('navbar-open')"><i class="fa fa-indent"></i></a>
                    <button class="search-form-input"><i class="fa fa-search"></i></button>
                </section>
            </div>
        </header>

        <main>
            <div id="pjax-container" class="container">
                <aside id="navbar" class="no-scrollbar">
                    
                    <section class="sidebar-nav">
                        
                            <div class="None" ><span><a href="/">Home</a></span></div>
                        
                            <div class="None" ><span><a href="/archives/">Archives</a></span></div>
                        
                            <div class="None" ><span><a href="/about/">About</a></span></div>
                        
                    </section>
                    
                    <section>
                        
    <div class=" "><span><a href="/category/Modem/">Modem</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/fuck-wuawei-hn8145xr/">HN8145XR光猫-河南移动-资料整理</a></li></ul></div><div class=" "><span><a href="/category/RTMP/">RTMP</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/xiu-ffmpeg-based-lan-video-recorder/">基于 Xiu 和 ffmpeg 的局域网录像机平替方案</a></li></ul></div><div class=" "><span><a href="/category/Android/">Android</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/android-make-storage-clean/">Android 如何保持眼中存储干净</a></li></ul></div><div class=" "><span><a href="/category/Win32/">Win32</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/windows-qemu-guest-enable-secure-boot/">QEMU运行Windows启用安全启动</a></li><li class=""><a href="/archives/win32-drive-letters-deviceid-harddisk-model/">Win32 盘符，设备号和硬盘型号</a></li><li class=""><a href="/archives/windirstat-recommend/">WinDirStat——Windows下存储分析的优秀方案</a></li><li class=""><a href="/archives/ScreenPlay/">Wallpaper Engine的开源替代品：ScreenPlay</a></li><li class=""><a href="/archives/add-icon-to-win32-exe/">给Win32程序加图标</a></li></ul></div><div class=" "><span><a href="/category/RAID/">RAID</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/software-raid-versus-hardware-raid/">软RAID vs 硬RAID</a></li></ul></div><div class="open "><span><a href="/category/Programming/">Programming</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/c23-quickview/">C23特性简介</a></li><li class="current"><a href="/archives/awesome-unstable-rust-features/">一些不错的Rust Unstable特性</a></li></ul></div><div class=" "><span><a href="/category/Linux/">Linux</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/enable-osdlyrics-netease-translation/">Osdlyrics 网易来源启用翻译</a></li><li class=""><a href="/archives/opengl-flipping/">OpenGL Flipping——记一次游戏直播闪屏修复过程</a></li></ul></div><div class=" "><span><a href="/category/Galgame/">Galgame</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/galgame-runs-on-linux/">在wine下运行galgame常见问题解决方案</a></li></ul></div>

                    </section>
                    <section hidden class="sidebar-external-link">
                        
                            <div class="external"><span><a href="https://liolok.com/">liolok</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://blog.i7.homes/">Integral</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="http://leoncha.online/">Leon Cha</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://www.aidenpers.xyz">aidenpers</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://controlnet.space/">ControlNet</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://sbchild.top/blog/">Sbchild</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://blog.bluempty.com/">HypengW</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                    </section>
                    <section class="maverick">
                        <div><span style="border: 1px solid #d4dadf;"><a href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Kepler</a></span></div>
                    </section>
                </aside>
                <div id="content-wrapper">
                    <div id="content">
    <section>
        <h1 class="post-title">一些不错的Rust Unstable特性</h1>
        <p class="post-meta">
            <time>July 28 2021</time>
            <span class="tags">
                
                <span>
                    <a href="/tag/Rust/">#Rust</a>
                </span>
                
                <span>
                    <a href="/tag/Language_feature/">#Language_feature</a>
                </span>
                
            </span>
        </p>
        <article class="yue"><h2>注意</h2>
<p>本文原文发布于2021-07-26，其中部分内容可能已经过时。请以 Rust RFC 为准。
已经稳定的特性见 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_feature/src/accepted.rs">accepted.rs</a>。</p><p>最后一次更新：2024-02-08</p><h2>关于翻译</h2>
<p>主要译者：<a href="https://github.com/poly000">poly000</a>，<a href="https://t.me/Hinanawi_Tenshi_M">比那名居</a></p><p>术语翻译部分参考了 <a href="https://rustwiki.org/wiki/translate/english-chinese-glossary-of-rust/">Rust 语言术语中英文对照表</a>。</p><p>如果有原文错误，请联系 <a href="https://twitter.com/efun_b">Ethan Brierley</a> 且联系我更新翻译。</p><p>参与：<a href="https://github.com/poly000/Maverick/">Maverick/demo_src</a></p><h2>Credits</h2>
<p><a href="https://lazy.codes/posts/awesome-unstable-rust-features/">原文</a> by <a href="https://twitter.com/efun_b">Ethan Brierley</a></p><h2>简介</h2>
<p>这篇文章介绍了一些尚不稳定的 Rust 编译器特性。我将会简单叙述这些特性，并不会深入太多细节。</p><h2>什么是Unstable Rust？</h2>
<p>Rust 有三个发布版本： stable，beta，nightly。</p><p>Nightly 编译器每天都会发布，而且只有它允许你启用 Unstable Rust 特性。</p><blockquote>
<p>这篇文章只讨论 Unstable 编译器特性，不讨论此版本的标准库特性。</p></blockquote>
<h2>为什么要用 Unstable 特性？</h2>
<p>Unstable Rust 可以让你使用在Stable Rust 中不允许使用的API。为此，编译器与标准库都使用了 Unstable 特性。</p><p>使用 Unstable 特性总是伴随着一些风险。它们经常会有一些不期望行为，有时甚至会破坏 Rust 的内存安全保证，导致未定义行为。这些特性可能开发的很好，但也能未开发完善。</p><p>使用Unstable特性的 Nightly 编译器，遇到“内部编译器错误”并不少见，这种情况通常称为<a href="https://github.com/rust-lang/rust/labels/I-ICE">ICE</a>。它发生于编译过程中，编译器将会panic。这可能是由于数据与查询操作因未完成的特性而被破坏，甚至可能只是因为没做完的特性中打了个 <code>todo!()</code>。</p><p>如果你遇到了ICE，检查一下是否已经被反馈，没有的话就把它报告给<a href="https://github.com/rust-lang/rust/issues">bug tracker</a>。</p><p>Rust 不保证在未来继续支持它的 Unstable 特性。
作为 Rust 开发者，我们享受着优秀的向下兼容性与稳定性，
而启用 Unstable 特性时，Rust不再提供这些保证。
今天工作的程序可能明天就寄了！</p><p>我决定学习 Unstable 特性，不是因为我需要用它们去解决实际问题，而是觉得他们很有意思。
对我来说，使用 Unstable 特性，可以让我有趣地，更多的参与语言本身的开发过程。</p><blockquote>
<p>Unstable 特性的完整列表见<a href="https://github.com/rust-lang/rust/blob/135ccbaca86ed4b9c0efaf0cd31442eae57ffad7/src/librustc_feature/active.rs#L83-L530">Unstable 特性列表</a>。</p></blockquote>
<h2>启用 Unstable 特性</h2>
<p>若要使用 Unstable 特性，首先你需要安装 Nightly 工具链：</p><div class="highlight"><pre><span></span>rustup<span class="w"> </span>toolchain<span class="w"> </span>install<span class="w"> </span>nightly
</pre></div>
<p>临时使用 Nightly 工具链，你可以在运行cargo时加上 <code>+nightly</code>。</p><div class="highlight"><pre><span></span>&lt;rust-command&gt;<span class="w"> </span>+nightly<span class="w"> </span>&lt;args&gt;
</pre></div>
<p>例如：</p><div class="highlight"><pre><span></span>cargo<span class="w"> </span>+nightly<span class="w"> </span>run
</pre></div>
<p>另外，你可以将你的默认编译器改为 Nightly ，这样你就不再需要加上 `+nightly。</p><div class="highlight"><pre><span></span>rustup<span class="w"> </span>default<span class="w"> </span>nightly
</pre></div>
<p>切换到 nightly 编译器后，你就可以使用 Unstable 特性。让我们试一试吧！</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>你会得到如下编译错误：</p><div class="highlight"><pre><span></span><span class="n">error</span><span class="p">[</span><span class="n">E0658</span><span class="p">]:</span><span class="w"> </span><span class="nc">box</span><span class="w"> </span><span class="n">expression</span><span class="w"> </span><span class="n">syntax</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">experimental</span><span class="p">;</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="err">`</span><span class="nb">Box</span><span class="p">::</span><span class="n">new</span><span class="err">`</span><span class="w"> </span><span class="n">instead</span>
<span class="w"> </span><span class="o">-</span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">18</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="n">my_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="o">^^^^^</span>
<span class="w">  </span><span class="o">|</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="nc">see</span><span class="w"> </span><span class="n">issue</span><span class="w"> </span><span class="p">#</span><span class="mi">49733</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span><span class="p">:</span><span class="c1">//github.com/rust-lang/rust/issues/49733&gt; for more information</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span><span class="p">:</span><span class="w"> </span><span class="nc">add</span><span class="w"> </span><span class="err">`</span><span class="cp">#![feature(box_syntax)]</span><span class="err">`</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">enable</span>
</pre></div>
<p>Rust 在 <code>help</code> 消息中准确地告诉了我们应该做什么——
我们需要用 <code>#![feature(box_syntax)]</code> 启用这个特性。</p><div class="highlight"><pre><span></span><span class="cp">#![feature(box_syntax)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>所有 Unstable 特性都需要用 <code>#![feature(..)]</code> 启用。
即使你忘记了，编译器通常也会指出要如何做，虽然不总会是。</p><p>现在，我们看看这些特性。
我把需要启用的特性名称放在每个特性的标题中的 <code>代码块</code> 中，在代码片段中省略，以保持简洁。</p><h2>控制流、模式和块</h2>
<h3><code>destructuring_assignment</code></h3>
<blockquote>
<p>于 Rust 1.59 稳定。</p></blockquote>
<p>在Rust中，我们经常在绑定到定义时解构某个类型。
我们一般会使用<code>let</code>绑定：</p><div class="highlight"><pre><span></span><span class="c1">// 创建两个变量, 一个是 x, 一个是 y </span>
<span class="kd">let</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">::</span><span class="n">random</span><span class="p">();</span>
</pre></div>
<p>目前这种写法只得在实例化新的定义时使用。
<code>destructuring_assignment</code> 将它拓展到赋值。</p><p>换句话说，我们可以不使用 <code>let</code> 完成解构。</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">::</span><span class="n">random</span><span class="p">();</span>
</pre></div>
<h3>从任意块提前返回，<code>label_break_value</code></h3>
<blockquote>
<p>于 Rust 1.65 稳定。</p></blockquote>
<p>Rust 有一个不那么广为人知的特性，<a href="https://doc.rust-lang.org/edition-guide/rust-2018/control-flow/loops-can-break-with-a-value.html"><code>loop</code>可以带值退出</a>。
就像 Rust 中许多其它的结构，在 Rust 中 <code>loop</code> 并不仅仅是语句, 而是<a href="https://doc.rust-lang.org/reference/statements-and-expressions.html">表达式</a>。</p><div class="highlight"><pre><span></span><span class="c1">// 保持请求用户输入一个数字，直到他们给出一个有效的数字。</span>
<span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">().</span><span class="n">parse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Invaid number, Please input a valid number&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><code>label_break_value</code> 把这拓展到任何被标记的块，而不仅仅是 <code>loop</code>。
它的行为，就像是一种提前的 <code>return</code> ，不过适用于任何代码块，而不只是函数体。</p><p>标记代码块的语法，和生命周期很相似。</p><div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="na">block</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// 这个代码块现在被标记为 &quot;block&quot; 。</span>
<span class="p">}</span>
</pre></div>
<p>现在也可以用同样的方式<a href="https://doc.rust-lang.org/rust-by-example/flow_control/loop/nested.html">标记<code>loop</code></a>。</p><p>我们可以把标签放在 <code>break</code> 后面，从那个代码块提前返回。</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&#39;</span><span class="na">block</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;block</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 从代码块提前返回</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>这个特性<a href="http://david.tribble.com/text/goto.html">不等价于goto</a>。
它没有 goto 那样的破坏性影响，他只是往后继续执行，从一个代码块中退出。</p></blockquote>
<h3>使用 <code>try_blocks</code> 内联 <code>?</code> 操作符的功能</h3>
<p><a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">版本引导</a>用这个例子解释问号运算符的工作方式：</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span><span class="p">::</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;username.txt&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>

<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>使用 <code>?</code> 操作符简化，可以得到等效的代码：</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span><span class="p">::</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;username.txt&quot;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>

<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p><code>?</code> 可以在函数中提前返回 <code>Err</code>。
<code>try_blocks</code> 提供了适用于任意代码块的相同功能。
使用 <code>try_blocks</code> ，我们可以内联 <code>read_usernames_from_file</code> 函数。</p><p><code>try_blocks</code> 和 <code>?</code> 的关系就像是 <code>label_break_value</code> 和 <code>return</code> 的关系。
<code>try_blocks</code> 的RFC提到了 <code>label_break_value</code> ，作为 <code>try_blocks</code> 一种可能的解糖。</p><p>接下来重写我们的 <code>read_username_from_file</code> ，
我们得到了一个简单的 <code>let</code> 绑定和 <code>try</code> 代码块。</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">read_username_from_file</span><span class="p">:</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span><span class="p">::</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;username.txt&quot;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>

<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>我喜欢这个特性。特别是对于较小的表达式，如果不提取成函数，可读性会更好。</p><h3><code>inline_const</code></h3>
<p>目前，指定某个值编译时计算需要定义一个常量。</p><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">PI_APPROX</span><span class="p">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">22.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">7.0</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">PI_APPROX</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>有了 <code>inline_const</code> 我们可以用匿名表达式完成同样的事。</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">22.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">7.0</span><span class="w"> </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
<p>在这个简单的例子中， 因为编译器优化 <a href="https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html">constant propagation</a>，<code>const</code> 块是不必要的。
但是对于更复杂的常量，用块来表示，可能会更好。</p><p>这个特性也允许在const块中使用模式匹配。
如 <code>match x { 1 + 3 =&gt; {} }</code> 会导致语法错误，而 <code>match x { const { 1 + 3 } =&gt; {} }</code> 不会。</p><h3><code>if_let_guard</code></h3>
<p>拓展 <code>match</code> 中的 <a href="https://doc.rust-lang.org/beta/rust-by-example/flow_control/match/guard.html"><code>if</code> 守卫</a> ，使其允许使用 <code>if let</code>。</p><h3><code>let_chains</code></h3>
<blockquote>
<p>于 Rust 1.64 稳定。</p></blockquote>
<p>目前，<code>if let</code> 和 <code>while let</code> 表达式不能以 <code>||</code> 或 <code>&amp;&amp;</code> 连接，
这个特性添加了支持。</p><h2>Traits</h2>
<h3><code>associated_type_bounds</code></h3>
<p>这是一个 stable Rust 函数：</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fizzbuzz</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">val</span><span class="o">|</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;FizzBuzz&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span>
<span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Fizz&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span>
<span class="w">        </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Buzz&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span>
<span class="w">        </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">}</span>
</pre></div>
<p>有了 <code>associated_type_bounds</code> 特性，对于这种情况，我们可以使用一个匿名类型：</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fizzbuzz</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="p">:</span><span class="w"> </span><span class="nc">Display</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span>
</pre></div>
<p>看看这个冗长重复的函数签名：</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">flatten_twice</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Flatten</span><span class="o">&lt;</span><span class="n">Flatten</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="p">,</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Item</span><span class="p">:</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="p">,</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="n">T</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Item</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Item</span><span class="p">:</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">iter</span><span class="p">.</span><span class="n">flatten</span><span class="p">().</span><span class="n">flatten</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>有了这个特性，我们就可以简单地写成：</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">flatten_twice</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Flatten</span><span class="o">&lt;</span><span class="n">Flatten</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="p">:</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="p">:</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">iter</span><span class="p">.</span><span class="n">flatten</span><span class="p">().</span><span class="n">flatten</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>这种写法容易理解许多。</p><h3><code>default_type_parameter_fallback</code>, <code>associated_type_defaults</code>以及<code>const_generics_defaults</code></h3>
<blockquote>
<p><code>const_generics_defaults</code> 于 Rust 1.59 稳定。</p></blockquote>
<p>这些特性允许你为 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0213-defaulted-type-params.md">泛型类型</a>, <a href="https://github.com/rust-lang/rfcs/blob/master/text/2532-associated-type-defaults.md">关联类型</a> 以及 <a href="#const-%E6%B3%9B%E5%9E%8B">const 变量</a> 在更多地方指定默认值。</p><p>它们允许你作为开发者创建更好的 API 。
如果一个crate的用户对细节不感兴趣，而它有默认值，则可以忽略细节。
这也让拓展 API 变得容易，无需做出破坏性更新。</p><h3><code>negative_impls</code> 和 <code>auto_traits</code></h3>
<p>这些特性都被标准库使用。<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> 和 <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> 都是自动 trait。</p><p><code>Send</code> trait <a href="https://doc.rust-lang.org/src/core/marker.rs.html#38-40">定义于标准库</a>：</p><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 空的</span>
<span class="p">}</span>
</pre></div>
<p>注意<code>auto</code>关键字，它让编译器为任意结构体/枚举体/联合体自动实现 <code>Send</code> trait，（前提是构成这个类型的类型都实现了<code>Send</code>）</p><p>如果每个类型都能简单地实现自动trait ，它们也不会那么有用。
这正是引入 <code>negative_impls</code> 的原因。</p><p><code>negative_impls</code> 允许一个类型不实现某个auto trait。
举个例子，<code>UnsafeCell</code>。不受限制的 <code>UnsafeCell</code> 在线程间共享非常不安全，因此它被标记为 <code>Sync</code> 也不安全。</p><div class="highlight"><pre><span></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="o">!</span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
<p>注意 <code>!</code> ，表示 “不<code>Sync</code>”。</p><h3><code>marker_trait_attr</code></h3>
<p>这个特性为 trait 添加了<code>#[marker]</code> 属性。</p><blockquote>
<p>详见 <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/marker-trait-attr.html">Unstable Book</a></p></blockquote>
<p>Rust 不允许定义trait的实现时覆盖此前的实现。
这样编译器就能确定要使用哪个实现——只有一个。</p><p>标志为 <code>#[marker]</code> 的 trait 不能在实现中覆盖任何东西。
这样它们就能允许重叠的实现，因为所有的实现都是一样的。</p><h3><code>type_alias_impl_trait</code>, <code>impl_trait_in_bindings</code> and <code>trait_alias</code></h3>
<p><code>impl Trait</code> 让编译器推导具体类型，把它换成实现了<code>Trait</code>的类型。
目前，<code>impl Trait</code>只能在函数参数或返回类型中使用，无法应用于变量绑定。</p><blockquote>
<p>注：impl_trait_in_binding 临时被移除(2022-07-26)，可能是因为它导致了<a href="https://github.com/rust-lang/rust/issues/83021">破坏性更新</a></p></blockquote>
<p>需要注意的是，使用 <code>type_alias_impl_trait</code> 时，类型必须是固定的。编译器会推断且应用单一具体的类型。</p><div class="highlight"><pre><span></span><span class="cp">#![feature(type_alias_impl_trait)]</span>

<span class="k">type</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">_</span><span class="p">:</span><span class="w"> </span><span class="nc">Foo</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="nb">String</span><span class="p">::</span><span class="n">new</span><span class="p">());</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<pre><code>error[E0308]: mismatched types
 --&gt; src/main.rs:9:9
  |
3 | type Foo = impl AsRef&lt;str&gt;;
  |            --------------- the expected opaque type
...
9 |     foo(&quot;&quot;);
  |     --- ^^ expected opaque type, found `&amp;str`
  |     |
  |     arguments to this function are incorrect
  |
  = note: expected opaque type `Foo`
               found reference `&amp;'static str`
note: function defined here
 --&gt; src/main.rs:5:4
  |
5 | fn foo(_: Foo) {}
  |    ^^^ ------
</code></pre>
<h3><code>fn_traits</code> and <code>unboxed_closures</code></h3>
<p><code>Fn</code>，<code>FnMut</code>和<code>FnOnce</code>被认为是<code>fn</code>的trait。
它们会被任何函数或者你创建的闭包自动实现，它们允许你给它们传参。</p><p>目前它们只能被自动实现。
<code>fn_trait</code> 则允许为任意类型提供自定义实现。
这就像是操作符重载，但要自定义的是<code>()</code>调用。</p><div class="highlight"><pre><span></span><span class="cp">#![feature(unboxed_closures)]</span><span class="w"> </span><span class="c1">// 实现带有`extern &quot;rust-call&quot;`的函数</span>
<span class="cp">#![feature(fn_traits)]</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Multiply</span><span class="p">;</span>

<span class="cp">#[allow(non_upper_case_globals)]</span>
<span class="k">const</span><span class="w"> </span><span class="n">multiply</span><span class="p">:</span><span class="w"> </span><span class="nc">Multiply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Multiply</span><span class="p">;</span>

<span class="k">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Multiply</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="p">::</span><span class="n">Output</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="mi">1</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Multiply</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="p">::</span><span class="n">Output</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="mi">2</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Multiply</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="p">::</span><span class="n">Output</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="mf">0.</span><span class="n">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="s">&quot;hello &quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;hello hello hello &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>这可被用于实现有点 hacky 的<a href="https://en.wikipedia.org/wiki/Function_overloading">函数重载</a>和<a href="https://en.wikipedia.org/wiki/Variadic_function">不定参函数</a>.</p><h2>语法糖</h2>
<h3><code>box_patterns</code> and <code>box_syntax</code></h3>
<p>这两个特性让<code>Box</code>的构造和析构变得更容易。
box关键字将取代<code>Box::new(...)</code>，并且允许在模式匹配中解引用<code>Box</code>。</p><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">TrashStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">head</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span>
<span class="w">    </span><span class="n">body</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">TrashStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TrashStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">elem</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">head</span><span class="p">:</span><span class="w"> </span><span class="nc">elem</span><span class="p">,</span>
<span class="w">            </span><span class="n">body</span><span class="p">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="bp">self</span><span class="p">),</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">TrashStack</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">body</span><span class="p">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="n">TrashStack</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}),</span>
<span class="w">            </span><span class="o">..</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">None</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>正如原文作者所说，rust（包括内部实现）正在减少box syntax的使用。</p><p>所以这个章节咕了（理直气壮）</p></blockquote>
<p>This makes things a little more ergonomic but I don't think there is much chance that this feature will ever be stabilised.
It seems to have existed forever with no plan for stabilisation but instead a little discussion about removing the feature.
<code>box_synatx</code> is used heavily in the compiler's source and a little in the standard library.</p><p>It is interesting to note that <code>box</code> does not desugar to <code>Box::new</code> but <code>Box::new</code> is implemented in the standard library with <code>box</code>.</p><div class="highlight"><pre><span></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">box</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
<h3><code>async_closure</code></h3>
<p>目前在闭包中使用异步代码你需要加async块。</p><div class="highlight"><pre><span></span><span class="n">app</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">});</span>
</pre></div>
<p><code>async_closure</code> 允许你将闭包本身标记为异步的，像异步函数那样写</p><div class="highlight"><pre><span></span><span class="n">app</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="k">async</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">));</span>
</pre></div>
<h3><code>in_band_lifetimes</code></h3>
<blockquote>
<p>于 <a href="https://github.com/rust-lang/rust/pull/93845">Rust #93845</a> 移除；</p><p>原始 RFC 中，不单独标注的提案被 Rust 拒绝。</p><p>详见 <a href="https://github.com/rust-lang/rust/issues/44524#issuecomment-988260463">Rust #44524</a> 。</p></blockquote>
<p>使用生命周期标记时，必须事先定义：</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">select</span><span class="o">&lt;&#39;</span><span class="na">data</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span><span class="w"> </span><span class="nc">Data</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Params</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span><span class="w"> </span><span class="nc">Item</span><span class="p">;</span>
</pre></div>
<p>使用 <code>in_band_lifetimes</code> ，生命周期可以不先显式定义。</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span><span class="w"> </span><span class="nc">Data</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Params</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">data</span><span class="w"> </span><span class="nc">Item</span><span class="p">;</span>
</pre></div>
<p>这是<a href="https://github.com/rust-lang/rfcs/pull/2115#issuecomment-323221054">生命周期</a>在rust <code>1.0.0</code>前的写法。</p><h3><code>format_args_capture</code></h3>
<blockquote>
<p>于 Rust 1.58 稳定。</p></blockquote>
<p>This allows for named arguments to be placed inside of strings inside any macro that depends on <code>std::format_args!</code>.
That includes <code>print!</code>, <code>format!</code>, <code>write!</code> and many more.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Ferris&quot;</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;你好{name}，你{age}岁了。&quot;</span><span class="p">);</span>
</pre></div>
<h3><code>crate_visibility_modifier</code></h3>
<blockquote>
<p>已于 <a href="https://github.com/rust-lang/rust/pull/97254">Rust #97254</a> 移除。</p><p>理由：</p><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="p">(</span><span class="k">crate</span><span class="w"> </span><span class="p">::</span><span class="n">std</span><span class="p">::</span><span class="n">path</span><span class="p">::</span><span class="n">Path</span><span class="p">);</span>
</pre></div>
<p>会产生歧义 <sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup></p></blockquote>
<p>这个特性允许你写 <code>crate struct Foo</code> 而不是 <code>pub(crate) struct Foo</code> ，语义不变。</p><h2>Types</h2>
<h3><code>type_ascription</code></h3>
<blockquote>
<p>已于 <a href="https://github.com/rust-lang/rust/issues/101728">Rust #101728</a> 移除</p><p>理由：语法不Rust</p></blockquote>
<p>用<code>Iterator</code>的<code>collect</code>方法举个例子：
collect将迭代器转换到集合</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">);</span>
</pre></div>
<p>这个不能编译，因为rust无法推导出<code>word</code>的类型。
可以把第一行换成：</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="p">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span>
</pre></div>
<p>有了<code>type_ascription</code>就不需要再加上let绑定，我们可以直接：</p><div class="highlight"><pre><span></span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">():</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
<p><code>: Type</code> 语法可以用在任何一处，提醒编译器“我在这里想要得到这个类型”</p><h3><code>never_type</code></h3>
<p>你可以定义没有变体的枚举体，
这种枚举体也存在于标准库中。</p><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">Infallible</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
<p>你可以在泛型或函数签名中使用该类型，但它不可能被构造。</p><p>元类型 <code>()</code> 等价于只有一个变体的枚举。
<code>never_type</code> 引入了一种新的类型，<code>!</code>等价于没有变体的 <code>Infallible</code>。</p><p>Because <code>!</code> can never be constructed it can be given special powers.
We don't have to handle the case of <code>!</code> because we have proven it will never exist.</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Loops without a <code>break</code> &quot;return <code>!</code>&quot; because they don't ever return.</p><p><code>!</code> can be very useful for expressing impossible outcomes in the type system.
Take for example the <code>FromStr</code> implementation on this <code>UserName</code> type.
This implementation is infallible because its implementation can never fail.
This allows us to set the <code>Err</code> variant to type <code>!</code>.</p><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">UserName</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span>

<span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UserName</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nb">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="p">;</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">Self</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">to_owned</span><span class="p">()))</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>It is then possible to use an empty <code>match</code> on the <code>Err</code> variant because <code>!</code> has no variants.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">UserName</span><span class="p">::</span><span class="n">from_str</span><span class="p">(</span><span class="s">&quot;ethan&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">,</span>
<span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">{},</span>
<span class="p">};</span>
</pre></div>
<h3><code>exhaustive_patterns</code></h3>
<blockquote>
<p>译注：原作者的解释和 RFC，Issue 都对不上。</p><p>原Issue目标为，不可达的分支可以省略</p><p>如析构一个 <code>Result&lt;T, !&gt;</code> ，</p><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">safe_unwrap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="o">!&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</blockquote>
<p>With the feature <code>exhaustive_patterns</code> the type system becomes smart enough for us to eliminate the <code>Err</code> branch altogether.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">UserName</span><span class="p">::</span><span class="n">from_str</span><span class="p">(</span><span class="s">&quot;ethan&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
<p>We can combine this with destructuring to remove the <code>match</code> leaving a beautiful line of code.</p><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">user_name</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UserName</span><span class="p">::</span><span class="n">from_str</span><span class="p">(</span><span class="s">&quot;ethan&quot;</span><span class="p">);</span>
</pre></div>
<h2>attribute</h2>
<blockquote>
<p>这个小节由 <a href="https://t.me/Hinanawi_Tenshi_M">@Hinanawi_Tenshi_M</a> 提供翻译，有改动</p></blockquote>
<h3><code>optimize_attribute</code></h3>
<p>你可以用 <code>Cargo.toml</code> 的 <a href="https://doc.rust-lang.org/book/ch14-01-release-profiles.html"><code>opt-level</code></a> 选项指定你想要怎么优化你的二进制文件。</p><p><code>opt-level</code> 指定的是整个 crate 的优化方式，如果你想要分别控制每一个项目的优化方式，你可以使用 <code>optimize_attribute</code> 选项。</p><div class="highlight"><pre><span></span><span class="cp">#[optimize(speed)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">fast_but_large</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="o">..</span><span class="p">.</span>
<span class="p">}</span>

<span class="cp">#[optimize(size)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">slow_but_small</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
<p>这对微调应用程序非常有用。在这些应用程序中，大小和性能的权衡特别重要。例如使用 <a href="https://webassembly.org/">web assembly</a> 时。</p><h3><code>stmt_expr_attributes</code></h3>
<p>这个特性让你可以在几乎任何地方标记属性，而不仅仅是顶层项目。例如，你可以在一个闭包上放一个<a href="#%60optimize_attribute%60">optimize attribute</a></p><h3><code>cfg_version</code></h3>
<p>该特性允许根据编译器版本进行条件编译。</p><div class="highlight"><pre><span></span><span class="cp">#[cfg(version(</span><span class="s">&quot;1.42&quot;</span><span class="cp">))]</span><span class="w"> </span><span class="c1">// 1.42 以上</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="cp">#[cfg(not(version(</span><span class="s">&quot;1.42&quot;</span><span class="cp">)))]</span><span class="w"> </span><span class="c1">// 1.41 以下</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>这使得你的 crate 能够使用最新的编译器功能，同时仍然保持对旧编译器的后备支持。</p><h3><code>no_core</code></h3>
<p>不依赖 <code>::std</code> 的 <code>#![no_std]</code> 选项已经存在很久了，</p><p><code>#![no_core]</code> 则对应着不依赖 <code>::core</code> 。</p><p>这对于不在完整环境中运行的应用非常重要，如嵌入式系统。
嵌入式系统通常没有操作系统，甚至没有动态内存，所以 <code>std</code> 中的许多功能都无法使用。</p><p>你现在可以通过 <code>#![no_core]</code> 表明不使用 libcore。</p><p>这样不会留下任何东西——你甚至不能使用libc。</p><h2>其它</h2>
<h3>Const 泛型</h3>
<blockquote>
<p>这个小节由 <a href="https://t.me/Hinanawi_Tenshi_M">@Hinanawi_Tenshi_M</a> 提供翻译，有改动。</p><p>已经在 Stable Rust 部分实现。 <sup class="footnote-ref" id="fnref-2"><a href="#fn-2">2</a></sup></p></blockquote>
<p>在都柏林 Rust 集会中，关于 <code>const_generics</code> ，我做过一场<a href="https://lazy.codes/posts/intro-to-const-generics/">演讲</a>。
与其重复那些内容，我更推荐大家去<a href="https://lazy.codes/posts/intro-to-const-generics/">看这个演讲</a>。</p><h3>Macros 2.0</h3>
<p>Rust的声明式宏非常强大。然而， <code>macro_rules!</code> 的一些规则，让我很困惑。</p><p><code>macro_rules!</code> 是一个简单的token转换过程，或者说，</p><ul>
<li>它接受一个token列表，输出新的token列表</li>
<li>可见性原则会遵从宏的调用处的规则。</li>
</ul>
<p>——因为代码只是被简单地粘贴回原处。</p><p><a href="https://veykril.github.io/tlborm/decl-macros/macros2.html">Macros 2.0</a> 介绍了<code>macro_rules!</code>的一种替代。</p><p>编写 Macros 2.0 只需使用关键字 <code>macro</code></p><p>它引入了一种新的格式，Hygiene 。Hygiene 允许宏应用它们定义处的可见性规则，而不是调用处。</p><h3><code>generators</code></h3>
<p>生成器（协程）提供了一种特殊的函数，可以在执行过程中暂停，“yield” 中间值给调用者。</p><p>生成器允许你使用<code>yield</code>关键字返回多个值，每次暂停该函数并返回给调用者。</p><p>生成器中也可以<code>return</code>单个值，不可再恢复。</p><p>大约三年前，我尝试编写算法，沿对角线遍历一个无穷的矩阵。我发现用Rust的迭代器编写它非常困难，最终放弃了。</p><p>这是我的实现，使用了Rust的生成器（协程）和一些我们刚刚讨论过的特性。</p><div class="highlight"><pre><span></span><span class="cp">#![feature(</span>
<span class="cp">    try_blocks,</span>
<span class="cp">    generators,</span>
<span class="cp">    generator_trait,</span>
<span class="cp">    associated_type_bounds,</span>
<span class="cp">    type_ascription</span>
<span class="cp">)]</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::{</span>
<span class="w">    </span><span class="n">iter</span><span class="p">,</span>
<span class="w">    </span><span class="n">ops</span><span class="p">::{</span><span class="n">Generator</span><span class="p">,</span><span class="w"> </span><span class="n">GeneratorState</span><span class="p">},</span>
<span class="w">    </span><span class="n">pin</span><span class="p">::</span><span class="n">Pin</span><span class="p">,</span>
<span class="p">};</span>

<span class="sd">/// Input</span>
<span class="sd">/// [[1, 2, 3]</span>
<span class="sd">/// ,[4, 5, 6]</span>
<span class="sd">/// ,[7, 8, 9]]</span>
<span class="sd">/// Output</span>
<span class="sd">/// [1, 2, 4, 3, 5, 7]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">diagonalize</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">matrix</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="p">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="w">        </span><span class="p">(</span><span class="kr">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">rows</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="o">?</span><span class="p">);</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">height</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">rows</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">rows</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="o">?</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="kr">yield</span><span class="w"> </span><span class="n">rows</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">next</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}):</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">iter</span><span class="p">::</span><span class="n">once</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">cycle</span><span class="p">().</span><span class="n">enumerate</span><span class="p">());</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">diagonals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diagonalize</span><span class="p">(</span><span class="n">matrix</span><span class="p">);</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">GeneratorState</span><span class="p">::</span><span class="n">Yielded</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pin</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">diagonals</span><span class="p">).</span><span class="n">resume</span><span class="p">(())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>It is understandable if you found the above snippet hard to interpret.
It makes use of a number of features that you may have just been introduced to.</p><p>There is a compelling argument against adding too many new features as they can greatly increase the learning curve.</p></blockquote>
<p>生成器让一些没有这个特性会难以编写甚至无法编写的实现变为可能。</p><p>生成器在标准库中是为了实现 async/await 添加的。
具体的语义在稳定化前很可能被修改，但它很有趣。</p><h3>总结</h3>
<p>我很抱歉，没有介绍其他三个不错的unstable特性：<a href="https://github.com/rust-lang/rfcs/blob/master/text/1598-generic_associated_types.md">GAT</a>, <a href="https://rust-lang.github.io/rfcs/2873-inline-asm.html">内联汇编</a>和<a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">特化</a>。
我只是感觉，在这篇文章中，我做不到客观的评价它们，不过将来我可能会尝试。</p><p>如果你想了解更多unstable特性，我推荐你看<a href="https://doc.rust-lang.org/beta/unstable-book/the-unstable-book.html">the unstable book</a>，这里会列出绝大部分。
Unstable book会连接到<a href="https://github.com/rust-lang/rust/labels/C-tracking-issue">tracking issue</a>，而后者往往会链接到<a href="https://rust-lang.github.io/rfcs/">RFC</a>。
组合使用这些来源，你可以很好地了解新特性。</p><p>Thank you for reading my first blog post 😃.
The best way to support me is by following my <a href="https://twitter.com/efun_b">Twitter</a>.
I am also looking for employment opportunities so please get in touch if you would like to talk about that.</p><section class="footnotes">
<ol>
<li id="fn-1"><p><a href="https://github.com/rust-lang/rust/issues/53120#issuecomment-1124065083">https://github.com/rust-lang/rust/issues/53120#issuecomment-1124065083</a><a href="#fnref-1" class="footnote">&#8617;</a></p></li>
<li id="fn-2"><p><a href="https://github.com/rust-lang/rust/issues/44580#issuecomment-1074040208">https://github.com/rust-lang/rust/issues/44580#issuecomment-1074040208</a><a href="#fnref-2" class="footnote">&#8617;</a></p></li>
</ol>
</section>
</article>
    </section>

    
    <section id="content-pager">
        
            <div class="next">
                <a class="card" href="/archives/c23-quickview/">
                    <time>October 01 2022</time>
                    <span>C23特性简介</span>
                </a>
            </div>
        
        
            <div class="prev">
                <a class="card" href="/archives/enable-osdlyrics-netease-translation/">
                    <time>July 25 2021</time>
                    <span>Osdlyrics 网易来源启用翻译</span>
                </a>
            </div>
        
    </section>
    

    
        <section id="comments">
            <div id="vcomments"></div>
        </section>
        <script>
            window.ValineOpt = {"enable": true, "el": "#vcomments", "appId": "IKRAfuPq0zrz6Wfje8ahHAIP-gzGzoHsz", "appKey": "lFaCWkd4xCs0Ng5UWs1eHNwU", "visitor": true, "recordIP": true};
            window.ValineOpt.path = window.location.pathname;
        </script>
    

    <script>
        document.body.classList.add('content');
        document.body.classList.remove('archive');
    </script>
</div>
                    <footer>
                        <span>Copyright © 2025 poly000</span>
                        
    <span class="leancloud_visitors"
            id="/archives/awesome-unstable-rust-features/" 
            data-flag-title="一些不错的Rust Unstable特性">
            <i class="fa fa-eye"></i> <i style="font-style: normal" class="leancloud-visitors-count"></i> Views
        </span>

                        
                    </footer>
                </div>
                
<aside id="toc-container" class="no-scrollbar">
    <span><i class="fa fa-align-right"></i> CONTENTS</span>
    <div id="toc"></div>
</aside>

            </div>
        </main>


        <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
        <script src="/assets/kepler-ef161b04d5.js"></script>
        <script>
            function ExSearchCall(item){
                if (item && item.length) {
                    $('.ins-close').click(); // 关闭搜索框
                    $('input.ins-search-input').val(''); // 清空
                    let url = item.attr('data-url'); // 获取目标页面 URL
                    $.pjax({url: url, 
                        container: '#pjax-container',
                        fragment: '#pjax-container',
                        timeout: 8000, }); // 发起一次 PJAX 请求
                }
            }
        </script>

        <!--Valine-->
        
            <script>
                var initValine = function () {
                    if (typeof window.ValineOpt === 'object' && $(window.ValineOpt.el).length) {
                        new Valine(window.ValineOpt);
                    }
                }
            </script>
            <script async src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        

        <!--ExSearch-->
        <script src="/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
        
        <!--katex-->
        <link rel="stylesheet" href="/assets/katex.min.css">
        <script defer src="/assets/katex.min.js"></script>
        <script>
        mathOpts = {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        };
        </script>
        <script defer src="/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

        
    </body>
</html>